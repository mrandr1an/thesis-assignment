\subsection{Γράφοντας το Project}

Θα δούμε πως η υλοποίηση του Project με βάση το specification που
έχουμε θέσει είναι ιδιαίτερα απλή. Παρόλα αυτά δεν προσφέρονται βιβλιοθήκες
για τον HC-SR04 όπως στην περίπτωση του ESP-IDF. Παράλληλα το API της
βιβλιοθήκης του MQTT είναι πολύ δύσκολα διαχειρήσημο οπότε θα
χρειαστεί κάποιου είδους βελτίωση χωρίς απαραίτητα να γράψουμε το
πρωτόκολλο από την αρχή (το οποίο όμως φαίνεται να είναι η ιδανική
λύση). Με βάση την γνώση που έχουμε δώσει στην εισαγωγή αυτού του
κεφαλαίου όμως γίνεται ξεκάθαρο πως αυτό δεν αποτελεί πρόβλημα καθώς η
εκφραστηκότητα της Rust κάνει το γράψιμο κώδικα να φαίνεται σαν πολύ
οργανική διαδικασία.

Μια επιλογή για να ξεκινήσουμε είναι να δημιουργήσουμε ένα Cargo.toml και
να θέσουμε τις βιβλιοθήκες που θέλουμε να μεταγλωττίσουμε μαζί με το Project.
Όμως υπάρχει μια καλύτερη λύση, το \verb|esp-generate --chip esp32c6 my_project|
δημιουργεί τα απαραίτητα αρχεία με τις βιβλιοθήκες που είναι απαραίτητες ανάλογα με
τις ρυθμίσεις μας. Προφανώς αν θέλουμε προσθέτουμε κιάλλες μπορούμε είτε από ένα τερματικό
\verb|cargo add library| είτε με το συντακτικό TOML που έχουμε δείξει παραπάνω.
Το τελικό directory έχει της εξής δομή:

\begin{figure}[htbp]
  \centering
\begin{forest}
for tree={
  font=\ttfamily,
  grow'=0,
  child anchor=west,
  parent anchor=south,
  anchor=west,
  calign=first,
  edge path={
    \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) +(5pt,0) |- (.child anchor)\forestoption{edge label};
  },
  before typesetting nodes={
    if n=1
      {insert before={[,phantom]}}
      {}
  },
  fit=band,
  before computing xy={l=15pt},
}
[.
  [build.rs]
  [.cargo
    [config.toml]
  ]
  [Cargo.toml]
  [.gitignore]
  [rust-toolchain.toml]
  [src
    [bin
      [main.rs]
    ]
    [lib.rs]
  ]
]
\end{forest}
\caption{Project folder structure.}
\label{fig:project_structure}
\end{figure}

Το project θα αποτελείτε από δύο δικές μας βιβλιοθήκες που θα είναι υπεύθυνες για:

\begin{enumerate}
  \item Την λειτουργία του αισθητήρα απόστασης.
  \item Την λειτουργεία του πρωτόκολλου MQTT.
\end{enumerate}

\subsubsection{HC-SR04 Driver}

Ο σένσορας για να λειτουργήσει χρειάζεται εκτός από το VCC και το ground pin
ένα input και ένα output. Οπότε γράφουμε σε ένα αρχείο \verb|hcsr04.rs|:

\begin{lstlisting}[language=Rust]
pub struct HCSR04<'h, Clock: Timer> {
    trigger: Output<'h>,
    echo: Input<'h>,
    clock: Clock,
}
\end{lstlisting}

Ήδη αρκετά κομμάτια στον κώδικα έχουν ιδιαίτερο ενδιαφέρον.

Αρχικά παρατηρούμε αρχικά ότι δεν χρησιμοποιούμε συγκεκριμένο τύπο για
GPIO pins. Χρησιμοποιώντας \verb|Input| και \verb|Output| όχι μόνο
μοντελοποιούμε καλύτερα τον αισθητήρα αλλά αποφεύγουμε μελλοντικά
runtime errors αν αφήναμε τον χρήστη να προσθέσει ότι pins ήθελε με
τις δικές του ρυθμίσεις. Με αυτόν τον τρόπο εκφράζουμε "ο αισθητήρας καταναλώνει
ένα output και ένα input pin".

Με την ίδια λογική ορίζουμε μια generic παράμετρο Clock η οποία περιορίζεται
στους τύπους που υλοποιούν το \verb|Timer| trait. Αφήνουμε λοιπόν στον
χρήστη να επιλέξει το ρολόι που θα χρησιμοποιήσει εφόσον οι περισσότεροι
μικροελεγκτές έχουν πολλά και ανάλογα με τους σκοπούς τα αποτελέσματα
μπορούν να διαφέρουν. Για τον ESP, αν μας ενδιαφέρει πάρα πολύ η εγκυρότητα των τιμών
του χρονομετρητή τότε συνήθως θέλουμε το system timer αλλιώς μπορούμε να επιλέξουμε
ένα από τα Timer Groups που προσφέρει ο ESP ή ένα software timer της embassy το οποίο
προφανώς βασίζεται σε ένα από τα παραπάνω.

Το συντακτικό \verb|<'h>| έχει να κάνει με τον χρόνο ζωής (lifetime)
των πεδίων στο εσωτερικό του struct. Η πλήρης ανάλυση των lifetimes
είναι εκτός των πλαισίων της εργασίας αλλά ουσιαστικά αυτό που
εκφράζουν είναι για πόσο χρόνο κατά την εκτέλεση του προγράμματος ζει
ένα σύμβολο. Στην συγκεκριμένη περίπτωση όλα ζουν για το ίδιο χρόνικό
διάστημα, μέχρι ο HCSR04 να βγει από το scope.

Όσο αναφορά τις μεθόδους του struct τις γράφουμε μέσα σε ένα \verb|impl|
block που διαθέτει τις κατάλληλες μεταβλητές

\begin{lstlisting}[language=Rust]
  impl<'h,Clock: Timer> HCSR04<'h, Clock>
  {
    //Methods go here
  }
\end{lstlisting}

Οι μεταβλητές αυτές είναι όσο πιο γενικές δυνατόν γίνεται. Θα μπορούσαμε
κάλιστα να ορίσουμε ένα πιο περιορισμένο implementation:


\begin{lstlisting}[language=Rust]

\end{lstlisting}

\subsubsection{MQTT Driver}
Goodbye
\subsubsection{Main Program}
Hellogoodbye

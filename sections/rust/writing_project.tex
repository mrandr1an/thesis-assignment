\subsection{Γράφοντας το Project}

Θα δούμε πως η υλοποίηση του Project με βάση το specification που
έχουμε θέσει είναι ιδιαίτερα απλή. Παρόλα αυτά δεν προσφέρονται βιβλιοθήκες
για τον HC-SR04 όπως στην περίπτωση του ESP-IDF. Παράλληλα το API της
βιβλιοθήκης του MQTT είναι πολύ δύσκολα διαχειρήσημο οπότε θα
χρειαστεί κάποιου είδους βελτίωση χωρίς απαραίτητα να γράψουμε το
πρωτόκολλο από την αρχή (το οποίο όμως φαίνεται να είναι η ιδανική
λύση). Με βάση την γνώση που έχουμε δώσει στην εισαγωγή αυτού του
κεφαλαίου όμως γίνεται ξεκάθαρο πως αυτό δεν αποτελεί πρόβλημα καθώς η
εκφραστηκότητα της Rust κάνει το γράψιμο κώδικα να φαίνεται σαν πολύ
οργανική διαδικασία.

Μια επιλογή για να ξεκινήσουμε είναι να δημιουργήσουμε ένα Cargo.toml και
να θέσουμε τις βιβλιοθήκες που θέλουμε να μεταγλωττίσουμε μαζί με το Project.
Όμως υπάρχει μια καλύτερη λύση, το \verb|esp-generate --chip esp32c6 my_project|
δημιουργεί τα απαραίτητα αρχεία με τις βιβλιοθήκες που είναι απαραίτητες ανάλογα με
τις ρυθμίσεις μας. Προφανώς αν θέλουμε προσθέτουμε κιάλλες μπορούμε είτε από ένα τερματικό
\verb|cargo add library| είτε με το συντακτικό TOML που έχουμε δείξει παραπάνω.
Το τελικό directory έχει της εξής δομή:

\begin{figure}[htbp]
  \centering
\begin{forest}
for tree={
  font=\ttfamily,
  grow'=0,
  child anchor=west,
  parent anchor=south,
  anchor=west,
  calign=first,
  edge path={
    \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) +(5pt,0) |- (.child anchor)\forestoption{edge label};
  },
  before typesetting nodes={
    if n=1
      {insert before={[,phantom]}}
      {}
  },
  fit=band,
  before computing xy={l=15pt},
}
[.
  [build.rs]
  [.cargo
    [config.toml]
  ]
  [Cargo.toml]
  [.gitignore]
  [rust-toolchain.toml]
  [src
    [bin
      [main.rs]
    ]
    [lib.rs]
  ]
]
\end{forest}
\caption{Project folder structure.}
\label{fig:project_structure}
\end{figure}

Το project θα αποτελείτε από δύο δικές μας βιβλιοθήκες που θα είναι υπεύθυνες για:

\begin{enumerate}
  \item Την λειτουργία του αισθητήρα απόστασης.
  \item Την λειτουργεία του πρωτόκολλου MQTT.
\end{enumerate}

\subsubsection{HC-SR04 Driver}

Ο σένσορας για να λειτουργήσει χρειάζεται εκτός από το VCC και το ground pin
ένα input και ένα output. Οπότε γράφουμε σε ένα αρχείο \verb|hcsr04.rs|:

\begin{lstlisting}[language=Rust]
pub struct HCSR04<'h, Clock: Timer> {
    trigger: Output<'h>,
    echo: Input<'h>,
    clock: Clock,
}
\end{lstlisting}

Ήδη αρκετά κομμάτια στον κώδικα έχουν ιδιαίτερο ενδιαφέρον.

Αρχικά παρατηρούμε ότι δεν χρησιμοποιούμε συγκεκριμένο τύπο για
GPIO pins. Χρησιμοποιώντας \verb|Input| και \verb|Output| όχι μόνο
μοντελοποιούμε καλύτερα τον αισθητήρα αλλά αποφεύγουμε μελλοντικά
runtime errors αν αφήναμε τον χρήστη να προσθέσει ότι pins ήθελε με
τις δικές του ρυθμίσεις. Με αυτόν τον τρόπο εκφράζουμε "ο αισθητήρας καταναλώνει
ένα output και ένα input pin".

Με την ίδια λογική ορίζουμε μια generic παράμετρο Clock η οποία περιορίζεται
στους τύπους που υλοποιούν το \verb|Timer| trait. Αφήνουμε λοιπόν στον
χρήστη να επιλέξει το ρολόι που θα χρησιμοποιήσει εφόσον οι περισσότεροι
μικροελεγκτές έχουν πολλά και ανάλογα με τους σκοπούς τα αποτελέσματα
μπορούν να διαφέρουν. Για τον ESP, αν μας ενδιαφέρει πάρα πολύ η εγκυρότητα των τιμών
του χρονομετρητή τότε συνήθως θέλουμε το system timer αλλιώς μπορούμε να επιλέξουμε
ένα από τα Timer Groups που προσφέρει ο ESP ή ένα software timer της embassy το οποίο
προφανώς βασίζεται σε ένα από τα παραπάνω.

Το συντακτικό \verb|<'h>| έχει να κάνει με τον χρόνο ζωής (lifetime)
των πεδίων στο εσωτερικό του struct. Η πλήρης ανάλυση των lifetimes
είναι εκτός των πλαισίων της εργασίας αλλά ουσιαστικά αυτό που
εκφράζουν είναι για πόσο χρόνο κατά την εκτέλεση του προγράμματος ζει
ένα σύμβολο. Στην συγκεκριμένη περίπτωση όλα ζουν για το ίδιο χρόνικό
διάστημα, μέχρι ο HCSR04 να βγει από το scope.

Όσο αναφορά τις μεθόδους του struct τις γράφουμε μέσα σε ένα \verb|impl|
block που διαθέτει τις κατάλληλες μεταβλητές. Τα \verb|impl| blocks εκφράζουν
το πιο μέθοδοι ορίζονται για έναν τύπο $T$.

\begin{lstlisting}[language=Rust]
  impl<'h,Clock: Timer> HCSR04<'h, Clock>
  {
    //Methods go here
  }
\end{lstlisting}

Οι μεταβλητές αυτές είναι όσο πιο γενικές δυνατόν γίνεται. Θα μπορούσαμε
κάλιστα να ορίσουμε ένα πιο περιορισμένο implementation. Για παράδειγμα να
ορίσουμε μεθόδους μόνο για τα HCSR04 που έχουν για χρονομετρητή ένα \verb|Alarm|:

\begin{lstlisting}[language=Rust]
  impl<'h> HCSR04<'h, Alarm>
  {
    //Methods go here
  }
\end{lstlisting}

Χρειαζόμαστε προφανώς μια συνάρτηση για να δημιουργήσουμε
το αντικείμενο που αντιπροσωπεύει τον αισθητήρα.

\begin{lstlisting}[language=Rust]
//inside the impl block
pub fn new<TRIG: PeripheralOutput + OutputPin, ECHO: PeripheralInput + InputPin>(
trigger: impl Peripheral<P = TRIG> + 'h,
echo: impl Peripheral<P = ECHO> + 'h,
timer: Clock,
) -> Self {
Self {
    trigger: Output::new(trigger, Level::Low),
    echo: Input::new(echo, Pull::None),
    clock: timer,
}
}
\end{lstlisting}

Η συνάρτηση έχει δύο παραμέτρους που είναι generic και πρέπει
να κάνουν implement το Peripheral trait (διαφορετικό από το Peripheral struct).

\begin{enumerate}
\item Η trigger είναι μια παράμετρος που κάνει implement το Peripheral
  και είναι PeripheralOutput + OutputPin. Δηλαδή αναγκάζουμε την συνάρτηση
  να δεχτεί GPIO Pins που λειτουργούν σαν outputs. Έστω ότι για κάποιο
  λόγο προσπαθήσουμε να καλέσουμε την συνάρτηση με trigger = VCC Pin
  το πρόγραμμα δεν θα κάνει compile επειδή το VCC Pin δεν κάνει implement
  το OutputPin.
\item Η echo είναι μια παράμετρος που κάνει implement το Peripheral
  και είναι PeripheralInput + InputPin. Δηλαδή αναγκάζουμε την συνάρτηση
  να δεχτεί GPIO Pins που λειτουργούν σαν inputs. Έστω ότι για κάποιο
  λόγο προσπαθήσουμε να καλέσουμε την συνάρτηση με echo = VCC Pin
  το πρόγραμμα δεν θα κάνει compile επειδή το VCC Pin δεν κάνει implement
  το InputPin.
\end{enumerate}

Η πιο ενδιαφέρουσα μέθοδος είναι αυτή που υπολογίζει την απόσταση:

\begin{lstlisting}[language=Rust]
//inside the impl block
pub fn measure_distance(&mut self) -> f64 {
    let delay = Delay::new();

    self.clock.start();
    //Send ultrasonic wave
    self.trigger.set_high();
    delay.delay_micros(10);
    self.trigger.set_low();
    //Ultra sonic wave is sent

    //Wait until echo bounces back
    while self.echo.is_low() {
        //DO NOT DEOPTIMIZE THE LOOP AWAY
        unsafe { asm!("nop") };
    }

    //Start timing start = CURRENT_TIME
    let start = self.clock.now();

    //Wait until echo pin returns to low
    while self.echo.is_high() {
        //DO NOT DEOPTIMIZE THE LOOP AWAY
        unsafe { asm!("nop") };
    }

    //End timing end = CURRENT_TIME > start
    let end = self.clock.now();

    let pulse_duration = (end - start).to_micros();

    //return the distance
    pulse_duration as f64 / 58_f64
}
\end{lstlisting}

\subsubsection{MQTT Driver}
Goodbye
\subsubsection{Main Program}
Hellogoodbye
